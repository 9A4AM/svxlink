<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Async: Async::Exec Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Async
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAsync.html">Async</a></li><li class="navelem"><a class="el" href="classAsync_1_1Exec.html">Exec</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classAsync_1_1Exec-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Async::Exec Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Execute external commands.  
 <a href="classAsync_1_1Exec.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Async::Exec:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAsync_1_1Exec.png" usemap="#Async::Exec_map" alt=""/>
  <map id="Async::Exec_map" name="Async::Exec_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32a192f041824be4c2cb49696d11cc75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a32a192f041824be4c2cb49696d11cc75">Exec</a> (const std::string &amp;cmdline=&quot;&quot;)</td></tr>
<tr class="memdesc:a32a192f041824be4c2cb49696d11cc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a32a192f041824be4c2cb49696d11cc75">More...</a><br /></td></tr>
<tr class="separator:a32a192f041824be4c2cb49696d11cc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30eac5a19a328ebf2c0e3814026a2eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#af30eac5a19a328ebf2c0e3814026a2eb">~Exec</a> (void)</td></tr>
<tr class="memdesc:af30eac5a19a328ebf2c0e3814026a2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af30eac5a19a328ebf2c0e3814026a2eb">More...</a><br /></td></tr>
<tr class="separator:af30eac5a19a328ebf2c0e3814026a2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77878c5f9874c4753423df858b23882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#aa77878c5f9874c4753423df858b23882">setCommandLine</a> (const std::string &amp;cmdline)</td></tr>
<tr class="memdesc:aa77878c5f9874c4753423df858b23882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the command line to use.  <a href="#aa77878c5f9874c4753423df858b23882">More...</a><br /></td></tr>
<tr class="separator:aa77878c5f9874c4753423df858b23882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12eb17251e37ea9de557a6b48298fb08"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a12eb17251e37ea9de557a6b48298fb08">command</a> (void) const </td></tr>
<tr class="memdesc:a12eb17251e37ea9de557a6b48298fb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the command name for the command.  <a href="#a12eb17251e37ea9de557a6b48298fb08">More...</a><br /></td></tr>
<tr class="separator:a12eb17251e37ea9de557a6b48298fb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa1b080d975eb477c97152a902cf5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a6fa1b080d975eb477c97152a902cf5f9">appendArgument</a> (const std::string &amp;arg)</td></tr>
<tr class="memdesc:a6fa1b080d975eb477c97152a902cf5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a command line argument to a command.  <a href="#a6fa1b080d975eb477c97152a902cf5f9">More...</a><br /></td></tr>
<tr class="separator:a6fa1b080d975eb477c97152a902cf5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad010c9613b38e847e1cef2dd577641ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#ad010c9613b38e847e1cef2dd577641ab">nice</a> (int inc=10)</td></tr>
<tr class="memdesc:ad010c9613b38e847e1cef2dd577641ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the nice value for the child subprocess.  <a href="#ad010c9613b38e847e1cef2dd577641ab">More...</a><br /></td></tr>
<tr class="separator:ad010c9613b38e847e1cef2dd577641ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e517458eda8710936679a8371f27c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a2e517458eda8710936679a8371f27c35">setTimeout</a> (int time_s)</td></tr>
<tr class="memdesc:a2e517458eda8710936679a8371f27c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a timeout on the allowed runtime for the subprocess.  <a href="#a2e517458eda8710936679a8371f27c35">More...</a><br /></td></tr>
<tr class="separator:a2e517458eda8710936679a8371f27c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c82fe6f09b61de215ad8fcf45209d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a63c82fe6f09b61de215ad8fcf45209d6">run</a> (void)</td></tr>
<tr class="memdesc:a63c82fe6f09b61de215ad8fcf45209d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the command.  <a href="#a63c82fe6f09b61de215ad8fcf45209d6">More...</a><br /></td></tr>
<tr class="separator:a63c82fe6f09b61de215ad8fcf45209d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca3a8fac965d0fef51c1fd603db8edc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a8ca3a8fac965d0fef51c1fd603db8edc">writeStdin</a> (const char *buf, int cnt)</td></tr>
<tr class="memdesc:a8ca3a8fac965d0fef51c1fd603db8edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to stdin on the subprocess.  <a href="#a8ca3a8fac965d0fef51c1fd603db8edc">More...</a><br /></td></tr>
<tr class="separator:a8ca3a8fac965d0fef51c1fd603db8edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217d7ce06b500b490592befb32d601c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a217d7ce06b500b490592befb32d601c9">writeStdin</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a217d7ce06b500b490592befb32d601c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to stdin on the subprocess.  <a href="#a217d7ce06b500b490592befb32d601c9">More...</a><br /></td></tr>
<tr class="separator:a217d7ce06b500b490592befb32d601c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241adb880bc7f5cc4e1e5700f7e90335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a241adb880bc7f5cc4e1e5700f7e90335">kill</a> (int sig=SIGTERM)</td></tr>
<tr class="memdesc:a241adb880bc7f5cc4e1e5700f7e90335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a UNIX signal to the subprocess.  <a href="#a241adb880bc7f5cc4e1e5700f7e90335">More...</a><br /></td></tr>
<tr class="separator:a241adb880bc7f5cc4e1e5700f7e90335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acba07acacab1c02d46f2b0abab0c04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a1acba07acacab1c02d46f2b0abab0c04">closeStdin</a> (void)</td></tr>
<tr class="memdesc:a1acba07acacab1c02d46f2b0abab0c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the stdin pipe to the subprocess.  <a href="#a1acba07acacab1c02d46f2b0abab0c04">More...</a><br /></td></tr>
<tr class="separator:a1acba07acacab1c02d46f2b0abab0c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a904dcfcabe96cf59ee68f591b78270"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a2a904dcfcabe96cf59ee68f591b78270">ifExited</a> (void) const </td></tr>
<tr class="memdesc:a2a904dcfcabe96cf59ee68f591b78270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the subprocess exited in a normal way.  <a href="#a2a904dcfcabe96cf59ee68f591b78270">More...</a><br /></td></tr>
<tr class="separator:a2a904dcfcabe96cf59ee68f591b78270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598531365f6514c9045c9b58de098120"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a598531365f6514c9045c9b58de098120">ifSignaled</a> (void) const </td></tr>
<tr class="memdesc:a598531365f6514c9045c9b58de098120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the subprocess exited due to receiving a UNIX signal.  <a href="#a598531365f6514c9045c9b58de098120">More...</a><br /></td></tr>
<tr class="separator:a598531365f6514c9045c9b58de098120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb03b17abbe41fe2b2a78cc821e38a97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#acb03b17abbe41fe2b2a78cc821e38a97">exitStatus</a> (void) const </td></tr>
<tr class="memdesc:acb03b17abbe41fe2b2a78cc821e38a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the exit code of the subprocess.  <a href="#acb03b17abbe41fe2b2a78cc821e38a97">More...</a><br /></td></tr>
<tr class="separator:acb03b17abbe41fe2b2a78cc821e38a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7e536ec1dacffa07ed6d7032420a38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#aaf7e536ec1dacffa07ed6d7032420a38">termSig</a> (void) const </td></tr>
<tr class="memdesc:aaf7e536ec1dacffa07ed6d7032420a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the UNIX signal number that caused the subprocess to stop.  <a href="#aaf7e536ec1dacffa07ed6d7032420a38">More...</a><br /></td></tr>
<tr class="separator:aaf7e536ec1dacffa07ed6d7032420a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ade595a1b38dd3ac6084cc08d00c7bae2"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, const char <br class="typebreak" />
*, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#ade595a1b38dd3ac6084cc08d00c7bae2">stdoutData</a></td></tr>
<tr class="memdesc:ade595a1b38dd3ac6084cc08d00c7bae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess write to stdout.  <a href="#ade595a1b38dd3ac6084cc08d00c7bae2">More...</a><br /></td></tr>
<tr class="separator:ade595a1b38dd3ac6084cc08d00c7bae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087a0307922271d9cc35f3acdfbf6313"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void, const char <br class="typebreak" />
*, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a087a0307922271d9cc35f3acdfbf6313">stderrData</a></td></tr>
<tr class="memdesc:a087a0307922271d9cc35f3acdfbf6313"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess write to stderr.  <a href="#a087a0307922271d9cc35f3acdfbf6313">More...</a><br /></td></tr>
<tr class="separator:a087a0307922271d9cc35f3acdfbf6313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11912f826cb67afc9d1d6d5a2e1ae714"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a11912f826cb67afc9d1d6d5a2e1ae714">stdoutClosed</a></td></tr>
<tr class="memdesc:a11912f826cb67afc9d1d6d5a2e1ae714"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess close its stdout.  <a href="#a11912f826cb67afc9d1d6d5a2e1ae714">More...</a><br /></td></tr>
<tr class="separator:a11912f826cb67afc9d1d6d5a2e1ae714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6">stderrClosed</a></td></tr>
<tr class="memdesc:ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess close its stderr.  <a href="#ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6">More...</a><br /></td></tr>
<tr class="separator:ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733c546fb3499918f3c4b614173f870a"><td class="memItemLeft" align="right" valign="top">sigc::signal&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsync_1_1Exec.html#a733c546fb3499918f3c4b614173f870a">exited</a></td></tr>
<tr class="memdesc:a733c546fb3499918f3c4b614173f870a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal that is emitted when the subprocess exits.  <a href="#a733c546fb3499918f3c4b614173f870a">More...</a><br /></td></tr>
<tr class="separator:a733c546fb3499918f3c4b614173f870a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Execute external commands. </p>
<dl class="section author"><dt>Author</dt><dd>Tobias Blomberg / SM0SVX </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2013-10-26</dd></dl>
<p>This class is used to execute external commands. It essentially wraps the exec system call together with commonly used infrastructure in a convenient class.</p>
<p>This class depends on the SIGCHLD UNIX signal so it must not be used by another part of the application.</p>
<div class="fragment"></div><!-- fragment --> 
<p>Definition at line <a class="el" href="AsyncExec_8h_source.html#l00131">131</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a32a192f041824be4c2cb49696d11cc75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Async::Exec::Exec </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="af30eac5a19a328ebf2c0e3814026a2eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Async::Exec::~Exec </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6fa1b080d975eb477c97152a902cf5f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::appendArgument </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a command line argument to a command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The command line argument to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1acba07acacab1c02d46f2b0abab0c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::closeStdin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the stdin pipe to the subprocess. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise</dd></dl>
<p>This method is used to close the pipe from the parent process to the subprocess. This will indicate to the subprocess that the parent process is done sending data to it. </p>

</div>
</div>
<a class="anchor" id="a12eb17251e37ea9de557a6b48298fb08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Async::Exec::command </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the command name for the command. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the command name </dd></dl>

<p>Definition at line <a class="el" href="AsyncExec_8h_source.html#l00159">159</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb03b17abbe41fe2b2a78cc821e38a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Async::Exec::exitStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the exit code of the subprocess. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the exit code (0-255) of the subprocess</dd></dl>
<p>This function may only be called after the process has exited. This is indicated by the "exited" signal. The returned value is only meaningful if the ifExited function returns <em>true</em>. </p>

</div>
</div>
<a class="anchor" id="a2a904dcfcabe96cf59ee68f591b78270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::ifExited </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the subprocess exited in a normal way. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> if it was a normal exit or <em>false</em> otherwise</dd></dl>
<p>This function may only be called after the process has exited. This is indicated by the "exited" signal. </p>

</div>
</div>
<a class="anchor" id="a598531365f6514c9045c9b58de098120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::ifSignaled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the subprocess exited due to receiving a UNIX signal. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> if it was a signal exit or <em>false</em> otherwise</dd></dl>
<p>This function may only be called after the process has exited. This is indicated by the "exited" signal. </p>

</div>
</div>
<a class="anchor" id="a241adb880bc7f5cc4e1e5700f7e90335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::kill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em> = <code>SIGTERM</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a UNIX signal to the subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>The UNIX signal to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ad010c9613b38e847e1cef2dd577641ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::nice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inc</em> = <code>10</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the nice value for the child subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inc</td><td>How much to increase the nice value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or else <em>false</em> </dd></dl>
<p>This function will modify the nice value of the subprocess. A positive value will increase the nice value (lower priority) and a negative value will decrease the nice value (higher priority). This function may be called both before and after the run method. </p>

</div>
</div>
<a class="anchor" id="a63c82fe6f09b61de215ad8fcf45209d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the command. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise</dd></dl>
<p>This method is used to run the command specified using the constructor, setCommandLine and appendArgument. This function will return success as long as the fork call succeeds. If the command cannot be run for some reason, this function will still return success. Errors that occurr after the fork call will be handled through the "exited" signal. If the command cannot run for some reason, the exit code will be 255. </p>

</div>
</div>
<a class="anchor" id="aa77878c5f9874c4753423df858b23882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::setCommandLine </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the command line to use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmdline</td><td>The command line to run</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to set the command line before the run method is called. The command line can also be set directly in the constructor. It's possible to append more arguments to the command line using the appendArgument method. </p>

</div>
</div>
<a class="anchor" id="a2e517458eda8710936679a8371f27c35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Async::Exec::setTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time_s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a timeout on the allowed runtime for the subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_s</td><td>The timeout time in seconds</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to limit the maximum runtime for the subprocess. If the process runs for longer than the specified time, a SIGTERM will be sent to it. If the subprocess has not exited withing ten seconds, a SIGKILL will be sent to the subprocess. </p>

</div>
</div>
<a class="anchor" id="aaf7e536ec1dacffa07ed6d7032420a38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Async::Exec::termSig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the UNIX signal number that caused the subprocess to stop. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the UNIX signal number</dd></dl>
<p>This function may only be called after the process has exited. This is indicated by the "exited" signal. The returned value is only meaningful if the ifSignaled function returns <em>true</em>. </p>

</div>
</div>
<a class="anchor" id="a8ca3a8fac965d0fef51c1fd603db8edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::writeStdin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to stdin on the subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to write data from </td></tr>
    <tr><td class="paramname">cnt</td><td>The number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a217d7ce06b500b490592befb32d601c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Async::Exec::writeStdin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to stdin on the subprocess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string buffer to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <em>true</em> on success or <em>false</em> otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a733c546fb3499918f3c4b614173f870a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void&gt; Async::Exec::exited</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess exits. </p>
<p>This signal will be emitted when the subprocess exits. After that the methods ifExited, ifSignaled, exitStatus and termSig may be used to find out what caused the subprocess to exit. </p>

<p>Definition at line <a class="el" href="AsyncExec_8h_source.html#l00312">312</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad11c7a94b4ea7d1f4ba6f9cbbf3ca1e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void&gt; Async::Exec::stderrClosed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess close its stderr. </p>

<p>Definition at line <a class="el" href="AsyncExec_8h_source.html#l00303">303</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a class="anchor" id="a087a0307922271d9cc35f3acdfbf6313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void, const char *, int&gt; Async::Exec::stderrData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess write to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer containing the data </td></tr>
    <tr><td class="paramname">cnt</td><td>The number of valid bytes in the buffer</td></tr>
  </table>
  </dd>
</dl>
<p>This signal is emitted when a subprocess write to its stderr. The data will be zero terminated. </p>

<p>Definition at line <a class="el" href="AsyncExec_8h_source.html#l00293">293</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a class="anchor" id="a11912f826cb67afc9d1d6d5a2e1ae714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void&gt; Async::Exec::stdoutClosed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess close its stdout. </p>

<p>Definition at line <a class="el" href="AsyncExec_8h_source.html#l00298">298</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<a class="anchor" id="ade595a1b38dd3ac6084cc08d00c7bae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sigc::signal&lt;void, const char *, int&gt; Async::Exec::stdoutData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal that is emitted when the subprocess write to stdout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer containing the data </td></tr>
    <tr><td class="paramname">cnt</td><td>The number of valid bytes in the buffer</td></tr>
  </table>
  </dd>
</dl>
<p>This signal is emitted when a subprocess write to its stdout. The data will be zero terminated. </p>

<p>Definition at line <a class="el" href="AsyncExec_8h_source.html#l00283">283</a> of file <a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="AsyncExec_8h_source.html">AsyncExec.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 3 2014 10:33:06 for Async by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
